import { prisma } from './prisma';
import { BalanceService } from './balance';
import type {
  Transaction,
  TransactionFormData,
  TransactionFilter,
  PaginatedResponse,
  PaginationParams,
  APIResponse
} from '@/types';

export class TransactionService {
  static async createTransaction(data: TransactionFormData & { userId: string }): Promise<APIResponse<Transaction>> {
    try {
      const transactionData: any = {
        userId: data.userId,
        date: new Date(data.date),
        dayOfWeek: new Date(data.date).toLocaleDateString('ja-JP', { weekday: 'short' }),
        paymentMethodId: data.paymentMethodId,
        store: data.store,
        purpose: data.purpose,
        type: data.type.toUpperCase() as 'INCOME' | 'EXPENSE',
        amount: data.amount,
      };

      // 支払い方法を取得して残高更新の準備
      const paymentMethod = await prisma.paymentMethod.findUnique({
        where: { id: data.paymentMethodId },
        include: { 
          bank: true,
          card: true,
        },
      });

      if (!paymentMethod) {
        return { success: false, error: '指定された支払い方法が見つかりません' };
      }

      // カード取引の場合、引き落とし予定日を設定
      if (paymentMethod.type === 'CARD' && paymentMethod.card) {
        if (data.cardWithdrawalDate) {
          // フォームで指定された引き落とし日を使用
          transactionData.cardWithdrawalDate = new Date(data.cardWithdrawalDate);
        } else {
          // 自動計算で引き落とし日を設定
          const withdrawalDate = this.calculateWithdrawalDate(new Date(data.date), paymentMethod.card);
          transactionData.cardWithdrawalDate = withdrawalDate;
        }
      }

      const transaction = await prisma.transaction.create({
        data: transactionData,
        include: {
          paymentMethod: {
            include: {
              bank: true,
              card: true,
            },
          },
        },
      });

      // 残高を更新（カード以外）
      if (paymentMethod.type !== 'CARD') {
        await BalanceService.processTransaction(
          data.userId,
          paymentMethod.type,
          paymentMethod.bankId,
          data.amount,
          transactionData.type
        );
      }

      return { success: true, data: transaction };
    } catch (error) {
      console.error('Transaction creation error:', error);
      return { success: false, error: '取引の作成に失敗しました' };
    }
  }

  static async getTransactions(
    userId: string,
    filter: TransactionFilter = {},
    pagination: PaginationParams = { page: 1, limit: 20 }
  ): Promise<APIResponse<PaginatedResponse<Transaction>>> {
    try {
      const where: any = {
        userId,
      };

      if (filter.startDate) {
        where.date = { gte: filter.startDate };
      }
      if (filter.endDate) {
        where.date = { ...where.date, lte: filter.endDate };
      }
      if (filter.paymentMethodId) {
        where.paymentMethodId = filter.paymentMethodId;
      }
      if (filter.type && filter.type !== 'all') {
        where.type = filter.type.toUpperCase();
      }
      if (filter.store) {
        where.store = { contains: filter.store, mode: 'insensitive' };
      }
      if (filter.purpose) {
        where.purpose = { contains: filter.purpose, mode: 'insensitive' };
      }

      const total = await prisma.transaction.count({ where });

      const transactions = await prisma.transaction.findMany({
        where,
        select: {
          id: true,
          userId: true,
          date: true,
          dayOfWeek: true,
          paymentMethodId: true,
          store: true,
          purpose: true,
          type: true,
          amount: true,
          isAutoGenerated: true,
          yearMonth: true,
          cashIncome: true,
          cashExpense: true,
          cashBalance: true,
          cardAmount: true,
          cardWithdrawalDate: true,
          bankIncome: true,
          bankExpense: true,
          bankBalance: true,
          createdAt: true,
          updatedAt: true,
          paymentMethod: {
            select: {
              id: true,
              name: true,
              type: true,
              bankId: true,
              cardId: true,
              userId: true,
            },
          },
        },
        orderBy: {
          [pagination.sortBy || 'date']: pagination.sortOrder || 'asc',
        },
        skip: (pagination.page - 1) * pagination.limit,
        take: pagination.limit,
      });

      const totalPages = Math.ceil(total / pagination.limit);

      return {
        success: true,
        data: {
          data: transactions,
          pagination: {
            page: pagination.page,
            limit: pagination.limit,
            total,
            totalPages,
            hasNext: pagination.page < totalPages,
            hasPrev: pagination.page > 1,
          },
        },
      };
    } catch (error) {
      return { success: false, error: '取引の取得に失敗しました' };
    }
  }

  static async updateTransaction(
    id: string,
    userId: string,
    data: Partial<TransactionFormData>
  ): Promise<APIResponse<Transaction>> {
    try {
      const updateData: any = {};
      
      if (data.date) {
        updateData.date = new Date(data.date);
        updateData.dayOfWeek = new Date(data.date).toLocaleDateString('ja-JP', { weekday: 'short' });
      }
      if (data.paymentMethodId) updateData.paymentMethodId = data.paymentMethodId;
      if (data.store !== undefined) updateData.store = data.store;
      if (data.purpose !== undefined) updateData.purpose = data.purpose;
      if (data.type) updateData.type = data.type.toUpperCase();
      if (data.amount !== undefined) updateData.amount = data.amount;
      if (data.cardWithdrawalDate !== undefined) {
        updateData.cardWithdrawalDate = data.cardWithdrawalDate ? new Date(data.cardWithdrawalDate) : null;
      }

      const transaction = await prisma.transaction.update({
        where: { 
          id,
          userId,
        },
        data: updateData,
        include: {
          paymentMethod: true,
        },
      });

      return { success: true, data: transaction };
    } catch (error) {
      return { success: false, error: '取引の更新に失敗しました' };
    }
  }

  static async deleteTransaction(id: string, userId: string): Promise<APIResponse<void>> {
    try {
      await prisma.transaction.delete({
        where: { 
          id,
          userId,
        },
      });

      return { success: true };
    } catch (error) {
      return { success: false, error: '取引の削除に失敗しました' };
    }
  }

  static async getTransactionById(id: string, userId: string): Promise<APIResponse<Transaction>> {
    try {
      const transaction = await prisma.transaction.findFirst({
        where: { 
          id,
          userId,
        },
        include: {
          paymentMethod: true,
        },
      });

      if (!transaction) {
        return { success: false, error: '取引が見つかりません' };
      }

      return { success: true, data: transaction };
    } catch (error) {
      return { success: false, error: '取引の取得に失敗しました' };
    }
  }

  // カード取引の引き落とし予定日を計算
  private static calculateWithdrawalDate(transactionDate: Date, card: any): Date {
    const txDate = new Date(transactionDate);
    const txYear = txDate.getFullYear();
    const txMonth = txDate.getMonth(); // 0-11
    const txDay = txDate.getDate();

    // 当月の締日
    const closingDate = new Date(txYear, txMonth, card.closingDay);

    let withdrawalYear: number;
    let withdrawalMonth: number;

    if (txDate >= closingDate) {
      // 締日以降の取引 → 翌月 + withdrawalMonthOffset分後に引き落とし
      withdrawalYear = txYear;
      withdrawalMonth = txMonth + 1 + card.withdrawalMonthOffset;
    } else {
      // 締日前の取引 → (withdrawalMonthOffset - 1)分後に引き落とし
      withdrawalYear = txYear;
      withdrawalMonth = txMonth + card.withdrawalMonthOffset - 1;
    }

    // 月の調整（12月を超えた場合の年跨ぎ処理）
    while (withdrawalMonth > 11) {
      withdrawalMonth -= 12;
      withdrawalYear += 1;
    }
    while (withdrawalMonth < 0) {
      withdrawalMonth += 12;
      withdrawalYear -= 1;
    }

    // 引き落とし予定日を作成
    const withdrawalDate = new Date(withdrawalYear, withdrawalMonth, card.withdrawalDay);

    // 該当月に指定日が存在しない場合（例：2月31日など）、月末に調整
    if (withdrawalDate.getMonth() !== withdrawalMonth) {
      withdrawalDate.setDate(0); // 前月の最終日
    }

    return withdrawalDate;
  }
}